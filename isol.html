<?php
echo '<?php';
echo '/*';
echo 'NOTE: miniProxy IS NO LONGER MAINTAINED AS OF APRIL 26th, 2020.';
echo 'IF YOU USE IT, YOU DO SO ENTIRELY AT YOUR OWN RISK.';
echo 'More information is available at <https://github.com/joshdick/miniProxy>.';
echo '*/';
echo '';
echo '/*';
echo 'miniProxy - A simple PHP web proxy. <https://github.com/joshdick/miniProxy>';
echo 'Written and maintained by Joshua Dick <http://joshdick.net>.';
echo 'miniProxy is licensed under the GNU GPL v3 <https://www.gnu.org/licenses/gpl-3.0.html>.';
echo '*/';
echo '';
echo '/****************************** START CONFIGURATION ******************************/';
echo '';
echo '//NOTE: If a given URL matches a pattern in both $whitelistPatterns and $blacklistPatterns,';
echo '//that URL will be treated as blacklisted.';
echo '';
echo '//To allow proxying any URL, set $whitelistPatterns to an empty array (the default).';
echo '//To only allow proxying of specific URLs (whitelist), add corresponding regular expressions';
echo '//to the $whitelistPatterns array. To prevent possible abuse, enter the narrowest/most-specific patterns possible.';
echo '//You can optionally use the "getHostnamePattern()" helper function to build a regular expression that';
echo '//matches all URLs for a given hostname.';
echo '$whitelistPatterns = [';
echo '//Usage example: To whitelist any URL at example.net, including sub-domains, uncomment the';
echo '//line below (which is equivalent to [ @^https?://([a-z0-9-]+\.)*example\.net@i ]):';
echo '//getHostnamePattern("example.net")';
echo '];';
echo '';
echo '//To disallow proxying of specific URLs (blacklist), add corresponding regular expressions';
echo '//to the $blacklistPatterns array. To prevent possible abuse, enter the broadest/least-specific patterns possible.';
echo '//You can optionally use the "getHostnamePattern()" helper function to build a regular expression that';
echo '//matches all URLs for a given hostname.';
echo '$blacklistPatterns = [';
echo '//Usage example: To blacklist any URL at example.net, including sub-domains, uncomment the';
echo '//line below (which is equivalent to [ @^https?://([a-z0-9-]+\.)*example\.net@i ]):';
echo '//getHostnamePattern("example.net")';
echo '];';
echo '';
echo '//To enable CORS (cross-origin resource sharing) for proxied sites, set $forceCORS to true.';
echo '$forceCORS = false;';
echo '';
echo '//Set to false to allow sites on the local network (where miniProxy is running) to be proxied.';
echo '$disallowLocal = true;';
echo '';
echo '//Set to false to report the client machine's IP address to proxied sites via the HTTP `x-forwarded-for` header.';
echo '//Setting to false may improve compatibility with some sites, but also exposes more information about end users to proxied sites.';
echo '$anonymize = true;';
echo '';
echo '//Start/default URL that that will be proxied when miniProxy is first loaded in a browser/accessed directly with no URL to proxy.';
echo '//If empty, miniProxy will show its own landing page.';
echo '$startURL = "";';
echo '';
echo '//When no $startURL is configured above, miniProxy will show its own landing page with a URL form field';
echo '//and the configured example URL. The example URL appears in the instructional text on the miniProxy landing page,';
echo '//and is proxied when pressing the 'Proxy It!' button on the landing page if its URL form is left blank.';
echo '$landingExampleURL = "https://example.net";';
echo '';
echo '/****************************** END CONFIGURATION ******************************/';
echo '';
echo 'ob_start("ob_gzhandler");';
echo '';
echo 'if (version_compare(PHP_VERSION, "5.4.7", "<")) {';
echo 'die("miniProxy requires PHP version 5.4.7 or later.");';
echo '}';
echo '';
echo '$requiredExtensions = ["curl", "mbstring", "xml"];';
echo 'foreach($requiredExtensions as $requiredExtension) {';
echo 'if (!extension_loaded($requiredExtension)) {';
echo 'die("miniProxy requires PHP's \"" . $requiredExtension . "\" extension. Please install/enable it on your server and try again.");';
echo '}';
echo '}';
echo '';
echo '//Helper function for use inside $whitelistPatterns/$blacklistPatterns.';
echo '//Returns a regex that matches all HTTP[S] URLs for a given hostname.';
echo 'function getHostnamePattern($hostname) {';
echo '$escapedHostname = str_replace(".", "\.", $hostname);';
echo 'return "@^https?://([a-z0-9-]+\.)*" . $escapedHostname . "@i";';
echo '}';
echo '';
echo '//Helper function that determines whether to allow proxying of a given URL.';
echo 'function isValidURL($url) {';
echo '//Validates a URL against the whitelist.';
echo 'function passesWhitelist($url) {';
echo 'if (count($GLOBALS['whitelistPatterns']) === 0) return true;';
echo 'foreach ($GLOBALS['whitelistPatterns'] as $pattern) {';
echo 'if (preg_match($pattern, $url)) {';
echo 'return true;';
echo '}';
echo '}';
echo 'return false;';
echo '}';
echo '';
echo '//Validates a URL against the blacklist.';
echo 'function passesBlacklist($url) {';
echo 'foreach ($GLOBALS['blacklistPatterns'] as $pattern) {';
echo 'if (preg_match($pattern, $url)) {';
echo 'return false;';
echo '}';
echo '}';
echo 'return true;';
echo '}';
echo '';
echo 'function isLocal($url) {';
echo '//First, generate a list of IP addresses that correspond to the requested URL.';
echo '$ips = [];';
echo '$host = parse_url($url, PHP_URL_HOST);';
echo 'if (filter_var($host, FILTER_VALIDATE_IP)) {';
echo '//The supplied host is already a valid IP address.';
echo '$ips = [$host];';
echo '} else {';
echo '//The host is not a valid IP address; attempt to resolve it to one.';
echo '$dnsResult = dns_get_record($host, DNS_A + DNS_AAAA);';
echo '$ips = array_map(function($dnsRecord) { return $dnsRecord['type'] == 'A' ? $dnsRecord['ip'] : $dnsRecord['ipv6']; }, $dnsResult);';
echo '}';
echo 'foreach ($ips as $ip) {';
echo '//Determine whether any of the IPs are in the private or reserved range.';
echo 'if (!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) {';
echo 'return true;';
echo '}';
echo '}';
echo 'return false;';
echo '}';
echo '';
echo 'return passesWhitelist($url) && passesBlacklist($url) && ($GLOBALS['disallowLocal'] ? !isLocal($url) : true);';
echo '}';
echo '';
echo '//Helper function used to removes/unset keys from an associative array using case insensitive matching';
echo 'function removeKeys(&$assoc, $keys2remove) {';
echo '$keys = array_keys($assoc);';
echo '$map = [];';
echo '$removedKeys = [];';
echo 'foreach ($keys as $key) {';
echo '$map[strtolower($key)] = $key;';
echo '}';
echo 'foreach ($keys2remove as $key) {';
echo '$key = strtolower($key);';
echo 'if (isset($map[$key])) {';
echo 'unset($assoc[$map[$key]]);';
echo '$removedKeys[] = $map[$key];';
echo '}';
echo '}';
echo 'return $removedKeys;';
echo '}';
echo '';
echo 'if (!function_exists("getallheaders")) {';
echo '//Adapted from http://www.php.net/manual/en/function.getallheaders.php#99814';
echo 'function getallheaders() {';
echo '$result = [];';
echo 'foreach($_SERVER as $key => $value) {';
echo 'if (substr($key, 0, 5) == "HTTP_") {';
echo '$key = str_replace(" ", "-", ucwords(strtolower(str_replace("_", " ", substr($key, 5)))));';
echo '$result[$key] = $value;';
echo '}';
echo '}';
echo 'return $result;';
echo '}';
echo '}';
echo '';
echo '$usingDefaultPort =  (!isset($_SERVER["HTTPS"]) && $_SERVER["SERVER_PORT"] === 80) || (isset($_SERVER["HTTPS"]) && $_SERVER["SERVER_PORT"] === 443);';
echo '$prefixPort = $usingDefaultPort ? "" : ":" . $_SERVER["SERVER_PORT"];';
echo '//Use HTTP_HOST to support client-configured DNS (instead of SERVER_NAME), but remove the port if one is present';
echo '$prefixHost = $_SERVER["HTTP_HOST"];';
echo '$prefixHost = strpos($prefixHost, ":") ? implode(":", explode(":", $_SERVER["HTTP_HOST"], -1)) : $prefixHost;';
echo '';
echo 'define("PROXY_PREFIX", "http" . (isset($_SERVER["HTTPS"]) ? "s" : "") . "://" . $prefixHost . $prefixPort . $_SERVER["SCRIPT_NAME"] . "?");';
echo '';
echo '//Makes an HTTP request via cURL, using request data that was passed directly to this script.';
echo 'function makeRequest($url) {';
echo '';
echo 'global $anonymize;';
echo '';
echo '//Tell cURL to make the request using the brower's user-agent if there is one, or a fallback user-agent otherwise.';
echo '$user_agent = $_SERVER["HTTP_USER_AGENT"];';
echo 'if (empty($user_agent)) {';
echo '$user_agent = "Mozilla/5.0 (compatible; miniProxy)";';
echo '}';
echo '$ch = curl_init();';
echo 'curl_setopt($ch, CURLOPT_USERAGENT, $user_agent);';
echo '';
echo '//Get ready to proxy the browser's request headers...';
echo '$browserRequestHeaders = getallheaders();';
echo '';
echo '//...but let cURL set some headers on its own.';
echo '$removedHeaders = removeKeys(';
echo '$browserRequestHeaders,';
echo '[';
echo '"Accept-Encoding", //Throw away the browser's Accept-Encoding header if any and let cURL make the request using gzip if possible.';
echo '"Content-Length",';
echo '"Host",';
echo '"Origin"';
echo ']';
echo ');';
echo '';
echo '$removedHeaders = array_map("strtolower", $removedHeaders);';
echo '';
echo 'curl_setopt($ch, CURLOPT_ENCODING, "");';
echo '//Transform the associative array from getallheaders() into an';
echo '//indexed array of header strings to be passed to cURL.';
echo '$curlRequestHeaders = [];';
echo 'foreach ($browserRequestHeaders as $name => $value) {';
echo '$curlRequestHeaders[] = $name . ": " . $value;';
echo '}';
echo 'if (!$anonymize) {';
echo '$curlRequestHeaders[] = "X-Forwarded-For: " . $_SERVER["REMOTE_ADDR"];';
echo '}';
echo '//Any `origin` header sent by the browser will refer to the proxy itself.';
echo '//If an `origin` header is present in the request, rewrite it to point to the correct origin.';
echo 'if (in_array("origin", $removedHeaders)) {';
echo '$urlParts = parse_url($url);';
echo '$port = $urlParts["port"];';
echo '$curlRequestHeaders[] = "Origin: " . $urlParts["scheme"] . "://" . $urlParts["host"] . (empty($port) ? "" : ":" . $port);';
echo '};';
echo 'curl_setopt($ch, CURLOPT_HTTPHEADER, $curlRequestHeaders);';
echo '';
echo '//Proxy any received GET/POST/PUT data.';
echo 'switch ($_SERVER["REQUEST_METHOD"]) {';
echo 'case "POST":';
echo 'curl_setopt($ch, CURLOPT_POST, true);';
echo '//For some reason, $HTTP_RAW_POST_DATA isn't working as documented at';
echo '//http://php.net/manual/en/reserved.variables.httprawpostdata.php';
echo '//but the php://input method works. This is likely to be flaky';
echo '//across different server environments.';
echo '//More info here: http://stackoverflow.com/questions/8899239/http-raw-post-data-not-being-populated-after-upgrade-to-php-5-3';
echo '//If the miniProxyFormAction field appears in the POST data, remove it so the destination server doesn't receive it.';
echo '$postData = [];';
echo 'parse_str(file_get_contents("php://input"), $postData);';
echo 'if (isset($postData["miniProxyFormAction"])) {';
echo 'unset($postData["miniProxyFormAction"]);';
echo '}';
echo 'curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($postData));';
echo 'break;';
echo 'case "PUT":';
echo 'curl_setopt($ch, CURLOPT_PUT, true);';
echo 'curl_setopt($ch, CURLOPT_INFILE, fopen("php://input", "r"));';
echo 'break;';
echo '}';
echo '';
echo '//Other cURL options.';
echo 'curl_setopt($ch, CURLOPT_HEADER, true);';
echo 'curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);';
echo 'curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);';
echo '';
echo '//Set the request URL.';
echo 'curl_setopt($ch, CURLOPT_URL, $url);';
echo '';
echo '//Make the request.';
echo '$response = curl_exec($ch);';
echo '$responseInfo = curl_getinfo($ch);';
echo '$headerSize = curl_getinfo($ch, CURLINFO_HEADER_SIZE);';
echo 'curl_close($ch);';
echo '';
echo '//Setting CURLOPT_HEADER to true above forces the response headers and body';
echo '//to be output together--separate them.';
echo '$responseHeaders = substr($response, 0, $headerSize);';
echo '$responseBody = substr($response, $headerSize);';
echo '';
echo 'return ["headers" => $responseHeaders, "body" => $responseBody, "responseInfo" => $responseInfo];';
echo '}';
echo '';
echo '//Converts relative URLs to absolute ones, given a base URL.';
echo '//Modified version of code found at http://nashruddin.com/PHP_Script_for_Converting_Relative_to_Absolute_URL';
echo 'function rel2abs($rel, $base) {';
echo 'if (empty($rel)) $rel = ".";';
echo 'if (parse_url($rel, PHP_URL_SCHEME) != "" || strpos($rel, "//") === 0) return $rel; //Return if already an absolute URL';
echo 'if ($rel[0] == "#" || $rel[0] == "?") return $base.$rel; //Queries and anchors';
echo 'extract(parse_url($base)); //Parse base URL and convert to local variables: $scheme, $host, $path';
echo '$path = isset($path) ? preg_replace("#/[^/]*$#", "", $path) : "/"; //Remove non-directory element from path';
echo 'if ($rel[0] == "/") $path = ""; //Destroy path if relative url points to root';
echo '$port = isset($port) && $port != 80 ? ":" . $port : "";';
echo '$auth = "";';
echo 'if (isset($user)) {';
echo '$auth = $user;';
echo 'if (isset($pass)) {';
echo '$auth .= ":" . $pass;';
echo '}';
echo '$auth .= "@";';
echo '}';
echo '$abs = "$auth$host$port$path/$rel"; //Dirty absolute URL';
echo 'for ($n = 1; $n > 0; $abs = preg_replace(["#(/\.?/)#", "#/(?!\.\.)[^/]+/\.\./#"], "/", $abs, -1, $n)) {} //Replace '//' or '/./' or '/foo/../' with '/'';
echo 'return $scheme . "://" . $abs; //Absolute URL is ready.';
echo '}';
echo '';
echo '//Proxify contents of url() references in blocks of CSS text.';
echo 'function proxifyCSS($css, $baseURL) {';
echo '//Add a "url()" wrapper to any CSS @import rules that only specify a URL without the wrapper,';
echo '//so that they're proxified when searching for "url()" wrappers below.';
echo '$sourceLines = explode("\n", $css);';
echo '$normalizedLines = [];';
echo 'foreach ($sourceLines as $line) {';
echo 'if (preg_match("/@import\s+url/i", $line)) {';
echo '$normalizedLines[] = $line;';
echo '} else {';
echo '$normalizedLines[] = preg_replace_callback(';
echo '"/(@import\s+)([^;\s]+)([\s;])/i",';
echo 'function($matches) use ($baseURL) {';
echo 'return $matches[1] . "url(" . $matches[2] . ")" . $matches[3];';
echo '},';
echo '$line);';
echo '}';
echo '}';
echo '$normalizedCSS = implode("\n", $normalizedLines);';
echo 'return preg_replace_callback(';
echo '"/url\((.*?)\)/i",';
echo 'function($matches) use ($baseURL) {';
echo '$url = $matches[1];';
echo '//Remove any surrounding single or double quotes from the URL so it can be passed to rel2abs - the quotes are optional in CSS';
echo '//Assume that if there is a leading quote then there should be a trailing quote, so just use trim() to remove them';
echo 'if (strpos($url, "'") === 0) {';
echo '$url = trim($url, "'");';
echo '}';
echo 'if (strpos($url, "\"") === 0) {';
echo '$url = trim($url, "\"");';
echo '}';
echo 'if (stripos($url, "data:") === 0) return "url(" . $url . ")"; //The URL isn't an HTTP URL but is actual binary data. Don't proxify it.';
echo 'return "url(" . PROXY_PREFIX . rel2abs($url, $baseURL) . ")";';
echo '},';
echo '$normalizedCSS);';
echo '}';
echo '';
echo '//Proxify "srcset" attributes (normally associated with <img> tags.)';
echo 'function proxifySrcset($srcset, $baseURL) {';
echo '$sources = array_map("trim", explode(",", $srcset)); //Split all contents by comma and trim each value';
echo '$proxifiedSources = array_map(function($source) use ($baseURL) {';
echo '$components = array_map("trim", str_split($source, strrpos($source, " "))); //Split by last space and trim';
echo '$components[0] = PROXY_PREFIX . rel2abs(ltrim($components[0], "/"), $baseURL); //First component of the split source string should be an image URL; proxify it';
echo 'return implode($components, " "); //Recombine the components into a single source';
echo '}, $sources);';
echo '$proxifiedSrcset = implode(", ", $proxifiedSources); //Recombine the sources into a single "srcset"';
echo 'return $proxifiedSrcset;';
echo '}';
echo '';
echo '//Extract and sanitize the requested URL, handling cases where forms have been rewritten to point to the proxy.';
echo 'if (isset($_POST["miniProxyFormAction"])) {';
echo '$url = $_POST["miniProxyFormAction"];';
echo 'unset($_POST["miniProxyFormAction"]);';
echo '} else {';
echo '$queryParams = [];';
echo 'parse_str($_SERVER["QUERY_STRING"], $queryParams);';
echo '//If the miniProxyFormAction field appears in the query string, make $url start with its value, and rebuild the the query string without it.';
echo 'if (isset($queryParams["miniProxyFormAction"])) {';
echo '$formAction = $queryParams["miniProxyFormAction"];';
echo 'unset($queryParams["miniProxyFormAction"]);';
echo '$url = $formAction . "?" . http_build_query($queryParams);';
echo '} else {';
echo '$url = substr($_SERVER["REQUEST_URI"], strlen($_SERVER["SCRIPT_NAME"]) + 1);';
echo '}';
echo '}';
echo 'if (empty($url)) {';
echo 'if (empty($startURL)) {';
echo 'die("<html><head><title>miniProxy</title></head><body><h1>Welcome to miniProxy!</h1>miniProxy can be directly invoked like this: <a href=\"" . PROXY_PREFIX . $landingExampleURL . "\">" . PROXY_PREFIX . $landingExampleURL . "</a><br /><br />Or, you can simply enter a URL below:<br /><br /><form onsubmit=\"if (document.getElementById('site').value) { window.location.href='" . PROXY_PREFIX . "' + document.getElementById('site').value; return false; } else { window.location.href='" . PROXY_PREFIX . $landingExampleURL . "'; return false; }\" autocomplete=\"off\"><input id=\"site\" type=\"text\" size=\"50\" /><input type=\"submit\" value=\"Proxy It!\" /></form></body></html>");';
echo '} else {';
echo '$url = $startURL;';
echo '}';
echo '} else if (strpos($url, ":/") !== strpos($url, "://")) {';
echo '//Work around the fact that some web servers (e.g. IIS 8.5) change double slashes appearing in the URL to a single slash.';
echo '//See https://github.com/joshdick/miniProxy/pull/14';
echo '$pos = strpos($url, ":/");';
echo '$url = substr_replace($url, "://", $pos, strlen(":/"));';
echo '}';
echo '$scheme = parse_url($url, PHP_URL_SCHEME);';
echo 'if (empty($scheme)) {';
echo 'if (strpos($url, "//") === 0) {';
echo '//Assume that any supplied URLs starting with // are HTTP URLs.';
echo '$url = "http:" . $url;';
echo '} else {';
echo '//Assume that any supplied URLs without a scheme (just a host) are HTTP URLs.';
echo '$url = "http://" . $url;';
echo '}';
echo '} else if (!preg_match("/^https?$/i", $scheme)) {';
echo 'die('Error: Detected a "' . $scheme . '" URL. miniProxy exclusively supports http[s] URLs.');';
echo '}';
echo '';
echo 'if (!isValidURL($url)) {';
echo 'die("Error: The requested URL was disallowed by the server administrator.");';
echo '}';
echo '';
echo '$response = makeRequest($url);';
echo '$rawResponseHeaders = $response["headers"];';
echo '$responseBody = $response["body"];';
echo '$responseInfo = $response["responseInfo"];';
echo '';
echo '//If CURLOPT_FOLLOWLOCATION landed the proxy at a diferent URL than';
echo '//what was requested, explicitly redirect the proxy there.';
echo '$responseURL = $responseInfo["url"];';
echo 'if ($responseURL !== $url) {';
echo 'header("Location: " . PROXY_PREFIX . $responseURL, true);';
echo 'exit(0);';
echo '}';
echo '';
echo '//A regex that indicates which server response headers should be stripped out of the proxified response.';
echo '$header_blacklist_pattern = "/^Content-Length|^Transfer-Encoding|^Content-Encoding.*gzip/i";';
echo '';
echo '//cURL can make multiple requests internally (for example, if CURLOPT_FOLLOWLOCATION is enabled), and reports';
echo '//headers for every request it makes. Only proxy the last set of received response headers,';
echo '//corresponding to the final request made by cURL for any given call to makeRequest().';
echo '$responseHeaderBlocks = array_filter(explode("\r\n\r\n", $rawResponseHeaders));';
echo '$lastHeaderBlock = end($responseHeaderBlocks);';
echo '$headerLines = explode("\r\n", $lastHeaderBlock);';
echo 'foreach ($headerLines as $header) {';
echo '$header = trim($header);';
echo 'if (!preg_match($header_blacklist_pattern, $header)) {';
echo 'header($header, false);';
echo '}';
echo '}';
echo '//Prevent robots from indexing proxified pages';
echo 'header("X-Robots-Tag: noindex, nofollow", true);';
echo '';
echo 'if ($forceCORS) {';
echo '//This logic is based on code found at: http://stackoverflow.com/a/9866124/278810';
echo '//CORS headers sent below may conflict with CORS headers from the original response,';
echo '//so these headers are sent after the original response headers to ensure their values';
echo '//are the ones that actually end up getting sent to the browser.';
echo '//Explicit [ $replace = true ] is used for these headers even though this is PHP's default behavior.';
echo '';
echo '//Allow access from any origin.';
echo 'header("Access-Control-Allow-Origin: *", true);';
echo 'header("Access-Control-Allow-Credentials: true", true);';
echo '';
echo '//Handle CORS headers received during OPTIONS requests.';
echo 'if ($_SERVER["REQUEST_METHOD"] == "OPTIONS") {';
echo 'if (isset($_SERVER["HTTP_ACCESS_CONTROL_REQUEST_METHOD"])) {';
echo 'header("Access-Control-Allow-Methods: GET, POST, OPTIONS", true);';
echo '}';
echo 'if (isset($_SERVER["HTTP_ACCESS_CONTROL_REQUEST_HEADERS"])) {';
echo 'header("Access-Control-Allow-Headers: {$_SERVER['HTTP_ACCESS_CONTROL_REQUEST_HEADERS']}", true);';
echo '}';
echo '//No further action is needed for OPTIONS requests.';
echo 'exit(0);';
echo '}';
echo '';
echo '}';
echo '';
echo '$contentType = "";';
echo 'if (isset($responseInfo["content_type"])) $contentType = $responseInfo["content_type"];';
echo '';
echo '//This is presumably a web page, so attempt to proxify the DOM.';
echo 'if (stripos($contentType, "text/html") !== false) {';
echo '';
echo '//Attempt to normalize character encoding.';
echo '$detectedEncoding = mb_detect_encoding($responseBody, "UTF-8, ISO-8859-1");';
echo 'if ($detectedEncoding) {';
echo '$responseBody = mb_convert_encoding($responseBody, "HTML-ENTITIES", $detectedEncoding);';
echo '}';
echo '';
echo '//Parse the DOM.';
echo '$doc = new DomDocument();';
echo '@$doc->loadHTML($responseBody);';
echo '$xpath = new DOMXPath($doc);';
echo '';
echo '//Rewrite forms so that their actions point back to the proxy.';
echo 'foreach($xpath->query("//form") as $form) {';
echo '$method = $form->getAttribute("method");';
echo '$action = $form->getAttribute("action");';
echo '//If the form doesn't have an action, the action is the page itself.';
echo '//Otherwise, change an existing action to an absolute version.';
echo '$action = empty($action) ? $url : rel2abs($action, $url);';
echo '//Rewrite the form action to point back at the proxy.';
echo '$form->setAttribute("action", rtrim(PROXY_PREFIX, "?"));';
echo '//Add a hidden form field that the proxy can later use to retreive the original form action.';
echo '$actionInput = $doc->createDocumentFragment();';
echo '$actionInput->appendXML('<input type="hidden" name="miniProxyFormAction" value="' . htmlspecialchars($action) . '" />');';
echo '$form->appendChild($actionInput);';
echo '}';
echo '//Proxify <meta> tags with an 'http-equiv="refresh"' attribute.';
echo 'foreach ($xpath->query("//meta[@http-equiv]") as $element) {';
echo 'if (strcasecmp($element->getAttribute("http-equiv"), "refresh") === 0) {';
echo '$content = $element->getAttribute("content");';
echo 'if (!empty($content)) {';
echo '$splitContent = preg_split("/=/", $content);';
echo 'if (isset($splitContent[1])) {';
echo '$element->setAttribute("content", $splitContent[0] . "=" . PROXY_PREFIX . rel2abs($splitContent[1], $url));';
echo '}';
echo '}';
echo '}';
echo '}';
echo '//Profixy <style> tags.';
echo 'foreach($xpath->query("//style") as $style) {';
echo '$style->nodeValue = proxifyCSS($style->nodeValue, $url);';
echo '}';
echo '//Proxify tags with a "style" attribute.';
echo 'foreach ($xpath->query("//*[@style]") as $element) {';
echo '$element->setAttribute("style", proxifyCSS($element->getAttribute("style"), $url));';
echo '}';
echo '//Proxify "srcset" attributes in <img> tags.';
echo 'foreach ($xpath->query("//img[@srcset]") as $element) {';
echo '$element->setAttribute("srcset", proxifySrcset($element->getAttribute("srcset"), $url));';
echo '}';
echo '//Proxify any of these attributes appearing in any tag.';
echo '$proxifyAttributes = ["href", "src"];';
echo 'foreach($proxifyAttributes as $attrName) {';
echo 'foreach($xpath->query("//*[@" . $attrName . "]") as $element) { //For every element with the given attribute...';
echo '$attrContent = $element->getAttribute($attrName);';
echo 'if ($attrName == "href" && preg_match("/^(about|javascript|magnet|mailto):|#/i", $attrContent)) continue;';
echo 'if ($attrName == "src" && preg_match("/^(data):/i", $attrContent)) continue;';
echo '$attrContent = rel2abs($attrContent, $url);';
echo '$attrContent = PROXY_PREFIX . $attrContent;';
echo '$element->setAttribute($attrName, $attrContent);';
echo '}';
echo '}';
echo '';
echo '//Attempt to force AJAX requests to be made through the proxy by';
echo '//wrapping window.XMLHttpRequest.prototype.open in order to make';
echo '//all request URLs absolute and point back to the proxy.';
echo '//The rel2abs() JavaScript function serves the same purpose as the server-side one in this file,';
echo '//but is used in the browser to ensure all AJAX request URLs are absolute and not relative.';
echo '//Uses code from these sources:';
echo '//http://stackoverflow.com/questions/7775767/javascript-overriding-xmlhttprequest-open';
echo '//https://gist.github.com/1088850';
echo '//TODO: This is obviously only useful for browsers that use XMLHttpRequest but';
echo '//it's better than nothing.';
echo '';
echo '$head = $xpath->query("//head")->item(0);';
echo '$body = $xpath->query("//body")->item(0);';
echo '$prependElem = $head != null ? $head : $body;';
echo '';
echo '//Only bother trying to apply this hack if the DOM has a <head> or <body> element;';
echo '//insert some JavaScript at the top of whichever is available first.';
echo '//Protects against cases where the server sends a Content-Type of "text/html" when';
echo '//what's coming back is most likely not actually HTML.';
echo '//TODO: Do this check before attempting to do any sort of DOM parsing?';
echo 'if ($prependElem != null) {';
echo '';
echo '$scriptElem = $doc->createElement("script",';
echo ''(function() {';
echo '';
echo 'if (window.XMLHttpRequest) {';
echo '';
echo 'function parseURI(url) {';
echo 'var m = String(url).replace(/^\s+|\s+$/g, "").match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);';
echo '// authority = "//" + user + ":" + pass "@" + hostname + ":" port';
echo 'return (m ? {';
echo 'href : m[0] || "",';
echo 'protocol : m[1] || "",';
echo 'authority: m[2] || "",';
echo 'host : m[3] || "",';
echo 'hostname : m[4] || "",';
echo 'port : m[5] || "",';
echo 'pathname : m[6] || "",';
echo 'search : m[7] || "",';
echo 'hash : m[8] || ""';
echo '} : null);';
echo '}';
echo '';
echo 'function rel2abs(base, href) { // RFC 3986';
echo '';
echo 'function removeDotSegments(input) {';
echo 'var output = [];';
echo 'input.replace(/^(\.\.?(\/|$))+/, "")';
echo '.replace(/\/(\.(\/|$))+/g, "/")';
echo '.replace(/\/\.\.$/, "/../")';
echo '.replace(/\/?[^\/]*/g, function (p) {';
echo 'if (p === "/..") {';
echo 'output.pop();';
echo '} else {';
echo 'output.push(p);';
echo '}';
echo '});';
echo 'return output.join("").replace(/^\//, input.charAt(0) === "/" ? "/" : "");';
echo '}';
echo '';
echo 'href = parseURI(href || "");';
echo 'base = parseURI(base || "");';
echo '';
echo 'return !href || !base ? null : (href.protocol || base.protocol) +';
echo '(href.protocol || href.authority ? href.authority : base.authority) +';
echo 'removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === "/" ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? "/" : "") + base.pathname.slice(0, base.pathname.lastIndexOf("/") + 1) + href.pathname) : base.pathname)) +';
echo '(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +';
echo 'href.hash;';
echo '';
echo '}';
echo '';
echo 'var proxied = window.XMLHttpRequest.prototype.open;';
echo 'window.XMLHttpRequest.prototype.open = function() {';
echo 'if (arguments[1] !== null && arguments[1] !== undefined) {';
echo 'var url = arguments[1];';
echo 'url = rel2abs("' . $url . '", url);';
echo 'if (url.indexOf("' . PROXY_PREFIX . '") == -1) {';
echo 'url = "' . PROXY_PREFIX . '" + url;';
echo '}';
echo 'arguments[1] = url;';
echo '}';
echo 'return proxied.apply(this, [].slice.call(arguments));';
echo '};';
echo '';
echo '}';
echo '';
echo '})();'';
echo ');';
echo '$scriptElem->setAttribute("type", "text/javascript");';
echo '';
echo '$prependElem->insertBefore($scriptElem, $prependElem->firstChild);';
echo '';
echo '}';
echo '';
echo 'echo "<!-- Proxified page constructed by miniProxy -->\n" . $doc->saveHTML();';
echo '} else if (stripos($contentType, "text/css") !== false) { //This is CSS, so proxify url() references.';
echo 'echo proxifyCSS($responseBody, $url);';
echo '} else { //This isn't a web page or CSS, so serve unmodified through the proxy with the correct headers (images, JavaScript, etc.)';
echo 'header("Content-Length: " . strlen($responseBody), true);';
echo 'echo $responseBody;';
echo '}';
echo '';
?>
